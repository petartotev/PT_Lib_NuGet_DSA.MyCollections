using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace PetarTotev.Net.DSA.MyCollections
{
    /// <summary>
    /// MyHashTable of TKey, TValue is the base of MyDictionary and MyHashSet. Based on the .GetHashCode() method, it stores the elements within an array. Each slot of the array is a LinkedList that contains KeyValuePairs.
    /// </summary>
    /// <typeparam name="TKey">Any generic type TKey.</typeparam>
    /// <typeparam name="TValue">Any generic type TValue.</typeparam>
    public class MyHashTable<TKey, TValue> : IEnumerable<MyKeyValuePair<TKey, TValue>>
    {
        private const int DefaultCapacity = 16;
        private const float LoadFactor = 0.7f;

        private MyLinkedListD<MyKeyValuePair<TKey, TValue>>[] array;

        /// <summary>
        /// MyHashTable is a constructor that creates a new MyHashTable.
        /// Then it creates a new array of MyLinkedListD, holding MyKeyValuePairs of TKey, TValue.
        /// The new array has either the capacity that comes as a constructor parameter or sets its capacity to a default value of 16.
        /// </summary>
        /// <param name="capacity"></param>
        public MyHashTable(int capacity = DefaultCapacity)
        {
            this.array = new MyLinkedListD<MyKeyValuePair<TKey, TValue>>[capacity];
        }

        /// <summary>
        /// Count is a property that returns the current count of all elements within the collection.
        /// </summary>
        public int Count { get; private set; }

        /// <summary>
        /// Capacity is a property that returns the current count of all elements within the collection.
        /// </summary>
        public int Capacity
        {
            get
            {
                return this.array.Length;
            }
        }

        /// <summary>
        /// [TKey key] returns a value contained in this TKey.
        /// </summary>
        /// <param name="key">Any generic type TKey.</param>
        /// <returns>A TValue that is a part of the KeyValuePair with a key equal to TKey key.</returns>
        public TValue this[TKey key]
        {
            get
            {
                return this.Get(key);
            }
            set
            {
                this.AddOrReplace(key, value);
            }
        }

        /// <summary>
        /// Keys returns an IEnumerable collection of all the TKeys within the collection.
        /// </summary>
        public IEnumerable<TKey> Keys
        {
            get
            {
                foreach (var slot in this.array.Where(x => x != null))
                {
                    foreach (var item in slot)
                    {
                        yield return item.Key;
                    }
                }
            }
        }

        /// <summary>
        /// Values returns an IEnumerable collection of all the TValues within the collection.
        /// </summary>
        public IEnumerable<TValue> Values
        {
            get
            {
                foreach (var slot in this.array.Where(x => x != null))
                {
                    foreach (var item in slot)
                    {
                        yield return item.Value;
                    }
                }
            }
        }

        /// <summary>
        /// Add is a void method that receives TKey key and TValue value as parameters. It grows the base array if needed.
        /// Then it creates a new MyKeyValuePair-TKey,TValue- and adds it to the LinkedList 
        /// at an index generated by a HashFunction based on the Tkey key.
        /// Complexity: O(1)-amortized.
        /// </summary>
        /// <param name="key"></param>
        /// <param name="value"></param>
        public void Add(TKey key, TValue value)
        {
            GrowIfNeeded();

            int index = GetIndexByHashFunction(key);

            if (this.array[index] == null)
            {
                this.array[index] = new MyLinkedListD<MyKeyValuePair<TKey, TValue>>();
            }

            foreach (var item in this.array[index])
            {
                if (item.Key.Equals(key))
                {
                    throw new ArgumentException("Key is already occupied.");
                }
            }

            MyKeyValuePair<TKey, TValue> myKVP = new MyKeyValuePair<TKey, TValue>(key, value);
            this.array[index].AddLast(myKVP);
            this.Count++;
        }

        /// <summary>
        /// AddOrReplace receives a TKey key and a TValue value parameters. If needed it Grows the array base. 
        /// If such a key does not exist a new element is created. 
        /// If not - the value of the TKey key would be overriden to be equal to TValue value parameter.
        /// Complexity: O(1).
        /// </summary>
        /// <param name="key">Any generic TKey key.</param>
        /// <param name="value">Any generic TValue value.</param>
        /// <returns>True if such element already exists, false if is created by the calling of this metod.</returns>
        public bool AddOrReplace(TKey key, TValue value)
        {
            GrowIfNeeded();

            int index = GetIndexByHashFunction(key);

            if (this.array[index] == null)
            {
                this.array[index] = new MyLinkedListD<MyKeyValuePair<TKey, TValue>>();
            }

            foreach (var item in this.array[index])
            {
                if (item.Key.Equals(key))
                {
                    item.Value = value;
                    return true;
                }
            }

            MyKeyValuePair<TKey, TValue> kvp = new MyKeyValuePair<TKey, TValue>(key, value);
            this.array[index].AddLast(kvp);
            this.Count++;
            return false;
        }

        /// <summary>
        /// Clear is a void method that resets the Array of LinkedLists which is the base of the MyHashTable.
        /// </summary>
        public void Clear()
        {
            this.array = new MyLinkedListD<MyKeyValuePair<TKey, TValue>>[DefaultCapacity];
            this.Count = 0;
        }

        /// <summary>
        /// ContainsKey is a method that receives a TKey element as a parameter and evaluates if the collection contains such a key.
        /// Complexity: O(1).
        /// </summary>
        /// <param name="key">Any generic type TKey.</param>
        /// <returns>A boolean that reveals if the element is present as a key in the hash table or not.</returns>
        public bool ContainsKey(TKey key)
        {
            int index = GetIndexByHashFunction(key);

            if (this.array[index] != null)
            {
                foreach (var myKeyValuePair in this.array[index])
                {
                    if (myKeyValuePair.Key.Equals(key))
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// ContainsValue is a method that receives a TValue element as a parameter and evaluates if the collection contains such a value.
        /// Complexity: O(n).
        /// </summary>
        /// <param name="value">Any generic type TValue.</param>
        /// <returns>A boolean that reveals if the element is present as a value in the hash table or not.</returns>
        public bool ContainsValue(TValue value)
        {
            foreach (var slot in this.array)
            {
                if (slot != null)
                {
                    foreach (var item in slot)
                    {
                        if (item.Value.Equals(value))
                        {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Get is a method that receives a parameter of TKey key and returns the TValue value of this key.
        /// If such key is not found an exception would be thrown.
        /// Complexity: O(1).
        /// </summary>
        /// <param name="key"></param>
        /// <returns>The value of the TKey key that is successfully localized in the collection.</returns>
        /// <exception cref="KeyNotFoundException">Thrown if this.Find(key) method returns null - such a key is not found.</exception>
        public TValue Get(TKey key)
        {
            MyKeyValuePair<TKey, TValue> kvp = this.Find(key);

            if (kvp == null)
            {
                throw new KeyNotFoundException();
            }

            return kvp.Value;
        }

        /// <summary>
        /// Find is a method that searches through the base array, finds a MyKeyValuePair with TKey key and then returns it.
        /// Complexity: O(1).
        /// </summary>
        /// <param name="key">Any generic TKey.</param>
        /// <returns>The MyKeyValuePair of TKey, TValue that is found in the collection and has the TKey key parameter as a key.</returns>
        public MyKeyValuePair<TKey, TValue> Find(TKey key)
        {
            int index = GetIndexByHashFunction(key);

            if (this.array[index] != null)
            {
                foreach (var item in this.array[index])
                {
                    if (item.Key.Equals(key))
                    {
                        return item;
                    }
                }
            }

            return null;
        }

        /// <summary>
        /// Remove is a method that returns bool if an element TKey key is contained 
        /// in the collection and is successfully removed from it.
        /// Complexity: O(1).
        /// </summary>
        /// <param name="key">Any generic type TKey.</param>
        /// <returns>A boolean that evaluates if such TKey key is found in the collection and is removed successfully.</returns>
        public bool Remove(TKey key)
        {
            int index = GetIndexByHashFunction(key);

            if (this.array[index] == null)
            {
                return false;
            }

            MyKeyValuePair<TKey, TValue> kvpToRemove = null;

            foreach (var item in this.array[index].Where(x => x != null))
            {
                if (item.Key.Equals(key))
                {
                    kvpToRemove = item;
                }
            }

            if (kvpToRemove == null)
            {
                return false;
            }

            this.array[index].Remove(kvpToRemove);
            this.Count--;
            return true;
        }

        /// <summary>
        /// TryGetValue is a method that returns true if such TKey key is found and sets the TValue value as equal to the TKey key value.
        /// Complexity: O(1).
        /// </summary>
        /// <param name="key">Any generic type TKey.</param>
        /// <param name="value">Any generic type TValue.</param>
        /// <returns>True if such TKey key is found and the TValue value is set to TKey key's value. False if such key is not found and the TValue value is set to its default.</returns>
        public bool TryGetValue(TKey key, out TValue value)
        {
            MyKeyValuePair<TKey, TValue> kvp = this.Find(key);

            if (kvp == null)
            {
                value = default(TValue);
                return false;
            }

            value = kvp.Value;
            return true;
        }

        /// <summary>
        /// GetEnumerator is an imperative method for all classes implementing the IEnumerable interface.
        /// Complexity: O(n).
        /// </summary>
        /// <returns>Yield returns the MyKeyValuePairs of TKey, TValue within the collection.</returns>
        public IEnumerator<MyKeyValuePair<TKey, TValue>> GetEnumerator()
        {
            foreach (var slot in this.array.Where(x => x != null))
            {
                foreach (var item in slot)
                {
                    yield return item;
                }
            }
        }
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }

        private int GetIndexByHashFunction(TKey key)
        {
            return Math.Abs(key.GetHashCode() % this.Capacity);
        }

        private void Grow()
        {
            MyHashTable<TKey, TValue> newHashTable = new MyHashTable<TKey, TValue>(this.Capacity * 2);

            foreach (var slot in this.array.Where(x => x != null))
            {
                foreach (var item in slot)
                {
                    newHashTable.AddOrReplace(item.Key, item.Value);
                }
            }

            this.array = newHashTable.array;
        }

        private void GrowIfNeeded()
        {
            float loadFactor = (float)(this.Count + 1) / this.Capacity;

            if (loadFactor >= LoadFactor)
            {
                Grow();
            }
        }
    }
}
